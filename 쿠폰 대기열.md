# Redis 기반 쿠폰 발급 대기열 서비스 구축 가이드

이 문서는 대규모 트래픽 상황에서 안정적인 쿠폰 발급을 위해 Redis를 활용한 대기열(Queue) 시스템을 구축하는 방법을 안내합니다.

## 1. 아키텍처 개요

사용자의 쿠폰 발급 요청을 동기적으로 DB에 저장하면, 트래픽이 몰릴 때 DB에 부하가 집중되어 시스템 전체의 성능 저하를 유발할 수 있습니다. 이를 해결하기 위해 다음과 같은 비동기 처리 방식을 도입합니다.

1.  **요청 접수 및 재고 차감**: 사용자의 요청을 받으면, 먼저 Redis에서 원자적(atomic)으로 재고를 차감합니다. (응답 속도가 매우 빠름)
2.  **대기열 추가**: 재고 차감에 성공하면, DB에 저장해야 할 쿠폰 발급 정보를 Redis의 List 자료구조(대기열)에 추가합니다. 이 작업까지 완료되면 사용자에게 즉시 "성공" 응답을 보냅니다.
3.  **비동기 DB 저장**: 별도의 Consumer(소비자)가 주기적으로 대기열을 확인하여, 쌓여있는 발급 정보들을 가져와 DB에 저장합니다.

### 처리 흐름

```
[Client] ----> [Controller] ----> [CouponService (V2, V3, ...)]
                                      |
                                      | 1. Redis 재고 차감 (DECR)
                                      |
                                      +-----> [Redis]
                                      |
                                      | 2. 대기열에 작업 추가 (RPUSH)
                                      |
                                      +-----> [Redis Queue]
                                      |
                                      | 3. Client에 즉시 성공 응답
                                      |
                                      V
                                  [Response]

(비동기 처리)

[CouponIssueQueueConsumer] <---- 4. 주기적으로 대기열 조회 (LPOP) ---- [Redis Queue]
        |
        | 5. DB에 쿠폰 정보 저장 (SAVE)
        |
        V
      [DB]
```

이 구조를 통해 사용자 요청에 대한 응답 시간을 최소화하고, DB 작업을 시스템 부하가 적은 상태에서 안정적으로 처리할 수 있습니다.

## 2. 구현 코드

### 2.1. `CouponIssueQueueService` (신규 생성)

쿠폰 발급 요청을 받아 Redis 대기열에 추가하는 역할을 담당하는 서비스입니다.

-   **파일 경로**: `src/main/java/com/example/sideProject/copon/Service/CouponIssueQueueService.java`
-   **주요 기능**:
    -   `CouponIssueRequest` 객체를 JSON 문자열로 변환합니다.
    -   Redis List의 `rightPush` 명령어를 사용해 대기열의 끝에 데이터를 추가합니다.

```java
package com.example.sideProject.copon.Service;

import com.example.sideProject.copon.dto.Coupon.CouponIssueRequest;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Service;

@Slf4j
@Service
@RequiredArgsConstructor
public class CouponIssueQueueService {

    private final StringRedisTemplate redisTemplate;
    private final ObjectMapper objectMapper;

    // 대기열의 Key로 사용할 상수
    private static final String QUEUE_KEY = "coupon:issue-queue";

    /**
     * 쿠폰 발급 요청을 대기열에 추가합니다.
     * @param request 쿠폰 발급 요청 DTO
     */
    public void addQueue(CouponIssueRequest request) {
        try {
            String requestJson = objectMapper.writeValueAsString(request);
            redisTemplate.opsForList().rightPush(QUEUE_KEY, requestJson);
        } catch (JsonProcessingException e) {
            log.error("Failed to serialize coupon issue request: {}", request, e);
            // 예외 처리 전략에 따라 추가 작업 수행 (e.g., 별도 로그, 재시도 큐)
        }
    }
}
```

### 2.2. `CouponIssueQueueConsumer` (신규 생성)

대기열에 쌓인 요청을 주기적으로 처리하여 DB에 저장하는 Consumer입니다.

-   **파일 경로**: `src/main/java/com/example/sideProject/copon/Service/CouponIssueQueueConsumer.java`
-   **주요 기능**:
    -   `@Scheduled` 어노테이션을 사용해 `1초(1000ms)` 마다 주기적으로 실행됩니다.
    -   Redis List의 `leftPop` 명령어를 사용해 대기열의 앞에서부터 데이터를 가져옵니다. (한 번에 최대 100개)
    -   가져온 JSON 데이터를 다시 객체로 변환하여 `CouponRepository`를 통해 DB에 저장합니다.

> **[INFO]**
> `@Scheduled`를 사용하려면 메인 애플리케이션 클래스에 `@EnableScheduling` 어노테이션을 추가해야 합니다.

```java
package com.example.sideProject.copon.Service;

import com.example.sideProject.copon.domain.Coupon;
import com.example.sideProject.copon.dto.Coupon.CouponIssueRequest;
import com.example.sideProject.copon.repository.CouponRepository;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Objects;

@Slf4j
@Component
@RequiredArgsConstructor
public class CouponIssueQueueConsumer {

    private final StringRedisTemplate redisTemplate;
    private final CouponRepository couponRepository;
    private final ObjectMapper objectMapper;

    private static final String QUEUE_KEY = "coupon:issue-queue";

    // 1초마다 실행 (fixedDelay = 1000)
    @Scheduled(fixedDelay = 1000)
    public void processQueue() {
        // 한 번에 최대 100개의 항목을 가져옴
        List<String> requests = redisTemplate.opsForList().leftPop(QUEUE_KEY, 100);

        if (requests == null || requests.isEmpty()) {
            return;
        }

        requests.stream()
                .filter(Objects::nonNull)
                .forEach(requestJson -> {
                    try {
                        CouponIssueRequest request = objectMapper.readValue(requestJson, CouponIssueRequest.class);
                        Coupon coupon = Coupon.issued(request.promotionId(), request.userId());
                        couponRepository.save(coupon);
                    } catch (JsonProcessingException e) {
                        log.error("Failed to process coupon issue request from queue: {}", requestJson, e);
                        // 실패한 요청에 대한 처리 (e.g., Dead Letter Queue로 이동)
                    }
                });
    }
}
```

### 2.3. `CouponV2RedisService` (수정)

기존 `CouponV2RedisService`가 DB에 직접 저장하는 대신, 새로 만든 `CouponIssueQueueService`를 호출하도록 수정합니다.

-   **파일 경로**: `src/main/java/com/example/sideProject/copon/Service/CouponV2RedisService.java`
-   **변경 사항**:
    -   `CouponRepository`와 `CouponAsyncSaver` 의존성을 제거합니다.
    -   `CouponIssueQueueService` 의존성을 추가합니다.
    -   Redis 재고 차감 성공 후, `couponRepository.save()` 대신 `couponIssueQueueService.addQueue()`를 호출합니다.

## 3. 향후 적용

`CouponV3Service`와 `CouponV4Service`에서 사용하던 자체 메모리 캐시(`HashMap`) 방식은 분산 환경에서 데이터 정합성 문제가 발생하므로, 위에서 구축한 Redis 기반 로직으로 점진적으로 교체하는 것을 권장합니다.

`CouponV2RedisService`와 동일하게, 재고 관리 로직만 각 서비스의 특성에 맞게 구현하고 DB 저장 부분은 `CouponIssueQueueService`를 호출하는 방식으로 통일하면 됩니다. 이를 통해 모든 쿠폰 발급 서비스가 일관되고 안정적인 아키텍처를 갖게 될 것입니다.